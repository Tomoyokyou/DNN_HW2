!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
C	../include/svm_struct_api_types.h	/^  double C;                    \/* trade-off between margin and loss *\/$/;"	m	struct:struct_learn_parm
CC	../svm_light/Makefile	/^CC = gcc$/;"	m
CC	../svm_struct/Makefile	/^CC = gcc$/;"	m
CFLAGS	../svm_light/Makefile	/^CFLAGS=  $(SFLAGS) -O3                     # release C-Compiler flags$/;"	m
CFLAGS	../svm_struct/Makefile	/^CFLAGS =    $(SFLAGS) -O3 -fomit-frame-pointer -ffast-math -Wall -g$/;"	m
CFLOAT	../svm_light/svm_common.h	34;"	d
CLASSIFICATION	../svm_light/svm_common.h	50;"	d
COMPACT_CACHED_VECTORS	../include/svm_struct_api_types.h	46;"	d
COMPACT_ROUNDING_THRESH	../include/svm_struct_api_types.h	53;"	d
CUSTOM	../svm_light/svm_common.h	47;"	d
DEFAULT_ALG_TYPE	../include/svm_struct_api_types.h	37;"	d
DEFAULT_EPS	../include/svm_struct_api_types.h	31;"	d
DEFAULT_LOSS_FCT	../include/svm_struct_api_types.h	35;"	d
DEFAULT_RESCALING	../include/svm_struct_api_types.h	33;"	d
DEF_LINDEP_SENSITIVITY	../svm_light/svm_hideo.c	49;"	d	file:
DEF_MAX_ITERATIONS	../svm_light/svm_hideo.c	48;"	d	file:
DEF_PRECISION	../svm_light/svm_hideo.c	47;"	d	file:
DEF_PRECISION_LINEAR	../svm_light/svm_loqo.c	29;"	d	file:
DEF_PRECISION_NONLINEAR	../svm_light/svm_loqo.c	30;"	d	file:
DOC	../svm_light/svm_common.h	/^} DOC;$/;"	t	typeref:struct:doc
DUAL_OPTIMAL	../svm_light/svm_hideo.c	37;"	d	file:
EPSILON_EQ	../svm_light/svm_hideo.c	51;"	d	file:
EPSILON_HIDEO	../svm_light/svm_hideo.c	50;"	d	file:
FNUM	../svm_light/svm_common.h	37;"	d
FNUM_MAX	../svm_light/svm_common.h	38;"	d
FVAL	../svm_light/svm_common.h	39;"	d
GRAM	../svm_light/svm_common.h	48;"	d
INCLUDE	../svm_struct/Makefile	/^INCLUDE= -I include\/\\$/;"	m
INST_NAME	../include/svm_struct_api_types.h	26;"	d
INST_VERSION	../include/svm_struct_api_types.h	27;"	d
INST_VERSION_DATE	../include/svm_struct_api_types.h	28;"	d
KERNEL_CACHE	../svm_light/svm_common.h	/^} KERNEL_CACHE;$/;"	t	typeref:struct:kernel_cache
KERNEL_PARM	../svm_light/svm_common.h	/^} KERNEL_PARM;$/;"	t	typeref:struct:kernel_parm
LABEL	../include/svm_struct_api_types.h	/^} LABEL;$/;"	t	typeref:struct:label
LABEL_MAX	../include/svm_struct_api_types.h	54;"	d
LARGEROUND	../svm_light/svm_hideo.c	42;"	d	file:
LD	../svm_light/Makefile	/^LD = gcc$/;"	m
LD	../svm_struct/Makefile	/^LD = gcc$/;"	m
LDFLAGS	../svm_struct/Makefile	/^LDFLAGS =   $(SFLAGS) -O3 -lm -Wall -g$/;"	m
LEARN_PARM	../svm_light/svm_common.h	/^} LEARN_PARM;$/;"	t	typeref:struct:learn_parm
LFLAGS	../svm_light/Makefile	/^LFLAGS=  $(SFLAGS) -O3                     # release linker flags$/;"	m
LIBS	../svm_light/Makefile	/^LIBS=-L. -lm                               # used libraries$/;"	m
LINEAR	../svm_light/svm_common.h	43;"	d
MATRIX	../svm_light/svm_common.h	/^} MATRIX;$/;"	t	typeref:struct:matrix
MAX	../svm_light/svm_common.c	23;"	d	file:
MAX	../svm_light/svm_learn.c	23;"	d	file:
MAX	../svm_struct/svm_struct_learn.c	26;"	d	file:
MAXFEATNUM	../svm_light/svm_common.h	40;"	d
MAXITER_EXCEEDED	../svm_light/svm_hideo.c	38;"	d	file:
MAXSHRINK	../svm_light/svm_common.h	55;"	d
MIN	../svm_light/svm_common.c	24;"	d	file:
MIN	../svm_light/svm_learn.c	24;"	d	file:
MIN	../svm_struct/svm_struct_learn.c	27;"	d	file:
MODEL	../svm_light/svm_common.h	/^} MODEL;$/;"	t	typeref:struct:model
NAN_SOLUTION	../svm_light/svm_hideo.c	39;"	d	file:
ONLY_ONE_VARIABLE	../svm_light/svm_hideo.c	40;"	d	file:
OPTIMIZATION	../svm_light/svm_common.h	53;"	d
PATTERN	../include/svm_struct_api_types.h	/^} PATTERN;$/;"	t	typeref:struct:pattern
POLY	../svm_light/svm_common.h	44;"	d
PRIMAL_OPTIMAL	../svm_light/svm_hideo.c	36;"	d	file:
QP	../svm_light/svm_common.h	/^} QP;$/;"	t	typeref:struct:quadratic_program
RANDPAIR	../svm_light/svm_common.h	/^} RANDPAIR;$/;"	t	typeref:struct:randpair
RANKING	../svm_light/svm_common.h	52;"	d
RBF	../svm_light/svm_common.h	45;"	d
REGRESSION	../svm_light/svm_common.h	51;"	d
SHRINK_STATE	../svm_light/svm_common.h	/^} SHRINK_STATE;$/;"	t	typeref:struct:shrink_state
SIGMOID	../svm_light/svm_common.h	46;"	d
SIGN	../svm_light/svm_common.c	25;"	d	file:
SIGN	../svm_light/svm_learn.c	25;"	d	file:
SMALLROUND	../svm_light/svm_hideo.c	43;"	d	file:
STRUCTMODEL	../include/svm_struct_api_types.h	/^} STRUCTMODEL;$/;"	t	typeref:struct:structmodel
STRUCT_LEARN_PARM	../include/svm_struct_api_types.h	/^} STRUCT_LEARN_PARM;$/;"	t	typeref:struct:struct_learn_parm
STRUCT_TEST_STATS	../include/svm_struct_api_types.h	/^} STRUCT_TEST_STATS;$/;"	t	typeref:struct:struct_test_stats
SVECTOR	../svm_light/svm_common.h	/^} SVECTOR;$/;"	t	typeref:struct:svector
SVM_COMMON	../svm_light/svm_common.h	20;"	d
SVM_LEARN	../svm_light/svm_learn.h	20;"	d
TIMING	../svm_light/svm_common.h	/^} TIMING;$/;"	t	typeref:struct:timing_profile
USE_FYCACHE	../include/svm_struct_api_types.h	39;"	d
VERSION	../svm_light/svm_common.h	31;"	d
VERSION_DATE	../svm_light/svm_common.h	32;"	d
WORD	../svm_light/svm_common.h	/^} WORD;$/;"	t	typeref:struct:word
_dim	../include/svm_struct_api_types.h	/^	size_t _dim;$/;"	m	struct:pattern
_fnum	../include/svm_struct_api_types.h	/^	size_t _fnum;$/;"	m	struct:pattern
_isEmpty	../include/svm_struct_api_types.h	/^	int  _isEmpty;$/;"	m	struct:label
_label	../include/svm_struct_api_types.h	/^	int* _label;$/;"	m	struct:label
_pattern	../include/svm_struct_api_types.h	/^	double* _pattern; $/;"	m	struct:pattern
_size	../include/svm_struct_api_types.h	/^	int  _size; \/\/ the number of frames in this utterance$/;"	m	struct:label
a_history	../svm_light/svm_common.h	/^  double **a_history;  \/* for shrinking with non-linear kernel *\/$/;"	m	struct:shrink_state
active	../svm_light/svm_common.h	/^  long   *active;$/;"	m	struct:shrink_state
active2totdoc	../svm_light/svm_common.h	/^  long   *active2totdoc;$/;"	m	struct:kernel_cache
activenum	../svm_light/svm_common.h	/^  long   activenum;$/;"	m	struct:kernel_cache
add_constraint_to_constraint_cache	../svm_struct/svm_struct_learn.c	/^double add_constraint_to_constraint_cache(CCACHE *ccache, MODEL *svmModel, int exnum, SVECTOR *fydelta, double rhs, double gainthresh, int maxconst, double *rt_cachesum)$/;"	f
add_dual_list_ns_r	../svm_light/svm_common.c	/^SVECTOR* add_dual_list_ns_r(SVECTOR *a, SVECTOR *b, double min_non_zero) $/;"	f
add_dual_list_sort_ss_r	../svm_light/svm_common.c	/^SVECTOR* add_dual_list_sort_ss_r(SVECTOR *a, SVECTOR *b, double min_non_zero) $/;"	f
add_dual_list_ss_r	../svm_light/svm_common.c	/^SVECTOR* add_dual_list_ss_r(SVECTOR *a, SVECTOR *b, double min_non_zero) $/;"	f
add_list_n_ns	../svm_light/svm_common.c	/^void add_list_n_ns(double *vec_n, SVECTOR *vec_s, double faktor)$/;"	f
add_list_ns	../svm_light/svm_common.c	/^SVECTOR* add_list_ns(SVECTOR *a)$/;"	f
add_list_ns_r	../svm_light/svm_common.c	/^SVECTOR* add_list_ns_r(SVECTOR *a, double min_non_zero) $/;"	f
add_list_sort_ss	../svm_light/svm_common.c	/^SVECTOR* add_list_sort_ss(SVECTOR *a) $/;"	f
add_list_sort_ss_r	../svm_light/svm_common.c	/^SVECTOR* add_list_sort_ss_r(SVECTOR *a, double min_non_zero) $/;"	f
add_list_ss	../svm_light/svm_common.c	/^SVECTOR* add_list_ss(SVECTOR *a) $/;"	f
add_list_ss_r	../svm_light/svm_common.c	/^SVECTOR* add_list_ss_r(SVECTOR *a, double min_non_zero) $/;"	f
add_ss	../svm_light/svm_common.c	/^SVECTOR* add_ss(SVECTOR *a, SVECTOR *b) $/;"	f
add_ss_r	../svm_light/svm_common.c	/^SVECTOR* add_ss_r(SVECTOR *a, SVECTOR *b, double min_non_zero) $/;"	f
add_to_index	../svm_light/svm_learn.c	/^void add_to_index(long int *index, long int elem)$/;"	f
add_vector_ns	../svm_light/svm_common.c	/^void add_vector_ns(double *vec_n, SVECTOR *vec_s, double faktor)$/;"	f
add_weight_vector_to_linear_model	../svm_light/svm_common.c	/^void add_weight_vector_to_linear_model(MODEL *model)$/;"	f
add_your_variables_here	../include/svm_struct_api_types.h	/^  int add_your_variables_here;$/;"	m	struct:struct_learn_parm
add_your_variables_here	../include/svm_struct_api_types.h	/^  int add_your_variables_here;$/;"	m	struct:structmodel
alpha	../svm_light/svm_common.h	/^  double  *alpha;$/;"	m	struct:model
alphafile	../svm_light/svm_common.h	/^  char alphafile[200];         \/* file to store optimal alphas in. use  $/;"	m	struct:learn_parm
append_svector_list	../svm_light/svm_common.c	/^void append_svector_list(SVECTOR *a, SVECTOR *b) $/;"	f
at_upper_bound	../svm_light/svm_common.h	/^  long    at_upper_bound;$/;"	m	struct:model
b	../svm_light/svm_common.h	/^  double  b;$/;"	m	struct:model
batch_size	../include/svm_struct_api_types.h	/^  double batch_size;           \/* size of the mini batches in percent$/;"	m	struct:struct_learn_parm
biased_hyperplane	../svm_light/svm_common.h	/^  long   biased_hyperplane;    \/* if nonzero, use hyperplane w*x+b=0 $/;"	m	struct:learn_parm
buffer	../svm_light/svm_common.h	/^  CFLOAT *buffer; \/* to improve speed *\/$/;"	m	struct:kernel_cache
buffer	../svm_light/svm_hideo.c	/^double *buffer;$/;"	v
buffsize	../svm_light/svm_common.h	/^  long   buffsize;$/;"	m	struct:kernel_cache
cache	../svm_light/svm_learn.h	/^  CFLOAT *cache;$/;"	m	struct:cache_parm_s
cache_kernel_row	../svm_light/svm_learn.c	/^void cache_kernel_row(KERNEL_CACHE *kernel_cache, DOC **docs, $/;"	f
cache_multiple_kernel_rows	../svm_light/svm_learn.c	/^void cache_multiple_kernel_rows(KERNEL_CACHE *kernel_cache, DOC **docs, $/;"	f
cache_parm_s	../svm_light/svm_learn.h	/^typedef struct cache_parm_s {$/;"	s
cache_parm_t	../svm_light/svm_learn.h	/^} cache_parm_t;$/;"	t	typeref:struct:cache_parm_s
calculate_qp_objective	../svm_light/svm_hideo.c	/^double calculate_qp_objective(opt_n,opt_g,opt_g0,alpha)$/;"	f
calculate_svm_model	../svm_light/svm_learn.c	/^long calculate_svm_model(DOC **docs, long int *label, long int *unlabeled, $/;"	f
ccache_size	../include/svm_struct_api_types.h	/^  int    ccache_size;          \/* maximum number of constraints to$/;"	m	struct:struct_learn_parm
check_learning_parms	../svm_light/svm_common.c	/^int check_learning_parms(LEARN_PARM *learn_parm, KERNEL_PARM *kernel_parm)$/;"	f
check_optimality	../svm_light/svm_learn.c	/^long check_optimality(MODEL *model, long int *label, long int *unlabeled, $/;"	f
check_optimality_sharedslack	../svm_light/svm_learn.c	/^long check_optimality_sharedslack(DOC **docs, MODEL *model, long int *label,$/;"	f
cholesky_matrix	../svm_light/svm_common.c	/^MATRIX *cholesky_matrix(MATRIX *A)$/;"	f
classify_example	../svm_light/svm_common.c	/^double classify_example(MODEL *model, DOC *ex) $/;"	f
classify_example_linear	../svm_light/svm_common.c	/^double classify_example_linear(MODEL *model, DOC *ex) $/;"	f
clear_index	../svm_light/svm_learn.c	/^void clear_index(long int *index)$/;"	f
clear_nvector	../svm_light/svm_common.c	/^void clear_nvector(double *vec, long int n)$/;"	f
coef_const	../svm_light/svm_common.h	/^  double  coef_const;$/;"	m	struct:kernel_parm
coef_lin	../svm_light/svm_common.h	/^  double  coef_lin;$/;"	m	struct:kernel_parm
compact_linear_model	../svm_light/svm_common.c	/^MODEL *compact_linear_model(MODEL *model)$/;"	f
compare_randpair	../svm_light/svm_common.c	/^int compare_randpair(const void *a, const void *b) $/;"	f
compareup_word	../svm_light/svm_common.c	/^int compareup_word(const void *a, const void *b) $/;"	f
compute_index	../svm_light/svm_learn.c	/^long compute_index(long int *binfeature, long int range, long int *index)$/;"	f
compute_loo	../svm_light/svm_common.h	/^  long   compute_loo;          \/* if nonzero, computes leave-one-out$/;"	m	struct:learn_parm
compute_matrices_for_optimization	../svm_light/svm_learn.c	/^void compute_matrices_for_optimization(DOC **docs, long int *label, $/;"	f
compute_objective_function	../svm_light/svm_learn.c	/^double compute_objective_function(double *a, double *lin, double *c, $/;"	f
compute_shared_slacks	../svm_light/svm_learn.c	/^void compute_shared_slacks(DOC **docs, long int *label, $/;"	f
compute_violation_of_constraint_in_cache	../svm_struct/svm_struct_learn.c	/^double compute_violation_of_constraint_in_cache(CCACHE *ccache, double thresh)$/;"	f
compute_xa_estimates	../svm_light/svm_learn.c	/^void compute_xa_estimates(MODEL *model, long int *label, $/;"	f
copy_matrix	../svm_light/svm_common.c	/^MATRIX *copy_matrix(MATRIX *matrix)$/;"	f
copy_model	../svm_light/svm_common.c	/^MODEL *copy_model(MODEL *model)$/;"	f
copy_svector	../svm_light/svm_common.c	/^SVECTOR *copy_svector(SVECTOR *vec)$/;"	f
copy_svector_shallow	../svm_light/svm_common.c	/^SVECTOR *copy_svector_shallow(SVECTOR *vec)$/;"	f
copyright_notice	../svm_light/svm_common.c	/^void copyright_notice(void)$/;"	f
costfactor	../svm_light/svm_common.h	/^  double  costfactor;          \/* Scales the cost of misclassifying this$/;"	m	struct:doc
create_constraint_cache	../svm_struct/svm_struct_learn.c	/^CCACHE *create_constraint_cache(SAMPLE sample, STRUCT_LEARN_PARM *sparm, $/;"	f
create_example	../svm_light/svm_common.c	/^DOC *create_example(long docnum, long queryid, long slackid, $/;"	f
create_matrix	../svm_light/svm_common.c	/^MATRIX *create_matrix(int n, int m)$/;"	f
create_nvector	../svm_light/svm_common.c	/^double *create_nvector(int n)$/;"	f
create_svector	../svm_light/svm_common.c	/^SVECTOR *create_svector(WORD *words,char *userdefined,double factor)$/;"	f
create_svector_n	../svm_light/svm_common.c	/^SVECTOR *create_svector_n(double *nonsparsevec, long maxfeatnum, char *userdefined, double factor)$/;"	f
create_svector_n_r	../svm_light/svm_common.c	/^SVECTOR *create_svector_n_r(double *nonsparsevec, long maxfeatnum, char *userdefined, double factor, double min_non_zero)$/;"	f
create_svector_shallow	../svm_light/svm_common.c	/^SVECTOR *create_svector_shallow(WORD *words,char *userdefined,double factor)$/;"	f
custom	../svm_light/svm_common.h	/^  char    custom[50];    \/* for user supplied kernel *\/$/;"	m	struct:kernel_parm
custom_argc	../include/svm_struct_api_types.h	/^  int    custom_argc;          \/* number of --* command line options *\/$/;"	m	struct:struct_learn_parm
custom_argv	../include/svm_struct_api_types.h	/^  char   custom_argv[50][300]; \/* storage for the --* command line options *\/$/;"	m	struct:struct_learn_parm
custom_kernel	../svm_light/kernel.h	/^double custom_kernel(KERNEL_PARM *kernel_parm, SVECTOR *a, SVECTOR *b) $/;"	f
deactnum	../svm_light/svm_common.h	/^  long   deactnum;$/;"	m	struct:shrink_state
distribute_alpha_t_greedily	../svm_light/svm_learn.c	/^double distribute_alpha_t_greedily(long int *sv2dnum, long int svnum, $/;"	f
doc	../svm_light/svm_common.h	/^typedef struct doc {$/;"	s
docfile	../svm_light/svm_classify.c	/^char docfile[200];$/;"	v
docfile	../svm_light/svm_learn_main.c	/^char docfile[200];           \/* file with training examples *\/$/;"	v
docnum	../svm_light/svm_common.h	/^  long    docnum;              \/* Document ID. This has to be the position of $/;"	m	struct:doc
docs	../svm_light/svm_learn.h	/^  DOC **docs; $/;"	m	struct:cache_parm_s
dual	../svm_light/svm_hideo.c	/^double *primal=0,*dual=0;$/;"	v
dual	../svm_light/svm_loqo.c	/^double *primal=0,*dual=0;$/;"	v
element	../svm_light/svm_common.h	/^  double **element;$/;"	m	struct:matrix
elems	../svm_light/svm_common.h	/^  long   elems;$/;"	m	struct:kernel_cache
eps	../svm_light/svm_common.h	/^  double eps;                  \/* regression epsilon (eps=1.0 for$/;"	m	struct:learn_parm
epsilon	../include/svm_struct_api_types.h	/^  double epsilon;              \/* precision for which to solve$/;"	m	struct:struct_learn_parm
epsilon_a	../svm_light/svm_common.h	/^  double epsilon_a;            \/* tolerable error on alphas at bounds *\/$/;"	m	struct:learn_parm
epsilon_const	../svm_light/svm_common.h	/^  double epsilon_const;        \/* tolerable error on eq-constraint *\/$/;"	m	struct:learn_parm
epsilon_crit	../svm_light/svm_common.h	/^  double epsilon_crit;         \/* tolerable error for distances used $/;"	m	struct:learn_parm
epsilon_shrink	../svm_light/svm_common.h	/^  double epsilon_shrink;       \/* how much a multiplier should be above $/;"	m	struct:learn_parm
estimate_margin_vcdim	../svm_light/svm_learn.c	/^double estimate_margin_vcdim(MODEL *model, double w, double R) $/;"	f
estimate_r_delta	../svm_light/svm_learn.c	/^double estimate_r_delta(DOC **docs, long int totdoc, KERNEL_PARM *kernel_parm)$/;"	f
estimate_r_delta_average	../svm_light/svm_learn.c	/^double estimate_r_delta_average(DOC **docs, long int totdoc, $/;"	f
estimate_sphere	../svm_light/svm_learn.c	/^double estimate_sphere(MODEL *model) $/;"	f
estimate_transduction_quality	../svm_light/svm_learn.c	/^void estimate_transduction_quality(MODEL *model, long int *label, $/;"	f
factor	../svm_light/svm_common.h	/^  double  factor;              \/* Factor by which this feature vector$/;"	m	struct:svector
featvec_eq	../svm_light/svm_common.c	/^int featvec_eq(SVECTOR *a, SVECTOR *b)$/;"	f
find_indep_subset_of_matrix	../svm_light/svm_common.c	/^double *find_indep_subset_of_matrix(MATRIX *A, double epsilon)$/;"	f
find_most_violated_constraint	../svm_struct/svm_struct_learn.c	/^void find_most_violated_constraint(SVECTOR **fydelta, double *rhs, $/;"	f
find_most_violated_joint_constraint_in_cache	../svm_struct/svm_struct_learn.c	/^double find_most_violated_joint_constraint_in_cache(CCACHE *ccache, double thresh, double *lhs_n, SVECTOR **lhs, double *rhs)$/;"	f
free_constraint_cache	../svm_struct/svm_struct_learn.c	/^void free_constraint_cache(CCACHE *ccache)$/;"	f
free_example	../svm_light/svm_common.c	/^void free_example(DOC *example, long deep)$/;"	f
free_matrix	../svm_light/svm_common.c	/^void free_matrix(MATRIX *matrix) $/;"	f
free_model	../svm_light/svm_common.c	/^void free_model(MODEL *model, int deep)$/;"	f
free_nvector	../svm_light/svm_common.c	/^void free_nvector(double *vector) $/;"	f
free_svector	../svm_light/svm_common.c	/^void free_svector(SVECTOR *vec)$/;"	f
free_svector_shallow	../svm_light/svm_common.c	/^void free_svector_shallow(SVECTOR *vec)$/;"	f
fvec	../svm_light/svm_common.h	/^  SVECTOR *fvec;               \/* Feature vector of the example. The$/;"	m	struct:doc
get_kernel_row	../svm_light/svm_learn.c	/^void get_kernel_row(KERNEL_CACHE *kernel_cache, DOC **docs, $/;"	f
get_runtime	../svm_light/svm_common.c	/^double get_runtime(void)$/;"	f
gram_matrix	../svm_light/svm_common.h	/^  MATRIX  *gram_matrix;  \/* here one can directly supply the kernel$/;"	m	struct:kernel_parm
identify_inconsistent	../svm_light/svm_learn.c	/^long identify_inconsistent(double *a, long int *label, $/;"	f
identify_misclassified	../svm_light/svm_learn.c	/^long identify_misclassified(double *lin, long int *label, $/;"	f
identify_one_misclassified	../svm_light/svm_learn.c	/^long identify_one_misclassified(double *lin, long int *label, $/;"	f
inactive_since	../svm_light/svm_common.h	/^  long   *inactive_since;$/;"	m	struct:shrink_state
incorporate_unlabeled_examples	../svm_light/svm_learn.c	/^long incorporate_unlabeled_examples(MODEL *model, long int *label, $/;"	f
index	../svm_light/svm_common.h	/^  long    *index;       \/* index from docnum to position in model *\/$/;"	m	struct:model
index	../svm_light/svm_common.h	/^  long   *index;  \/* cache some kernel evalutations *\/$/;"	m	struct:kernel_cache
init_iter	../svm_light/svm_loqo.c	/^long   init_iter=500,precision_violations=0;$/;"	v
init_kernel_matrix	../svm_struct/svm_struct_learn.c	/^MATRIX *init_kernel_matrix(CONSTSET *cset, KERNEL_PARM *kparm) $/;"	f
init_margin	../svm_light/svm_loqo.c	/^double init_margin=0.15;$/;"	v
init_shrink_state	../svm_light/svm_learn.c	/^void init_shrink_state(SHRINK_STATE *shrink_state, long int totdoc, $/;"	f
invert_ltriangle_matrix	../svm_light/svm_common.c	/^MATRIX *invert_ltriangle_matrix(MATRIX *L)$/;"	f
invindex	../svm_light/svm_common.h	/^  long   *invindex;$/;"	m	struct:kernel_cache
isnan	../svm_light/svm_common.c	/^int isnan(double a)$/;"	f
kernel	../svm_light/svm_common.c	/^double kernel(KERNEL_PARM *kernel_parm, DOC *a, DOC *b) $/;"	f
kernel_cache	../svm_light/svm_common.h	/^typedef struct kernel_cache {$/;"	s
kernel_cache	../svm_light/svm_learn.h	/^  KERNEL_CACHE *kernel_cache;$/;"	m	struct:cache_parm_s
kernel_cache_check	../svm_light/svm_learn.c	/^long kernel_cache_check(KERNEL_CACHE *kernel_cache, long int docnum)$/;"	f
kernel_cache_clean_and_malloc	../svm_light/svm_learn.c	/^CFLOAT *kernel_cache_clean_and_malloc(KERNEL_CACHE *kernel_cache, $/;"	f
kernel_cache_cleanup	../svm_light/svm_learn.c	/^void kernel_cache_cleanup(KERNEL_CACHE *kernel_cache)$/;"	f
kernel_cache_free	../svm_light/svm_learn.c	/^void kernel_cache_free(KERNEL_CACHE *kernel_cache, long int i)$/;"	f
kernel_cache_free_lru	../svm_light/svm_learn.c	/^long kernel_cache_free_lru(KERNEL_CACHE *kernel_cache) $/;"	f
kernel_cache_init	../svm_light/svm_learn.c	/^KERNEL_CACHE *kernel_cache_init(long int totdoc, long int buffsize)$/;"	f
kernel_cache_malloc	../svm_light/svm_learn.c	/^long kernel_cache_malloc(KERNEL_CACHE *kernel_cache)$/;"	f
kernel_cache_reset_lru	../svm_light/svm_learn.c	/^void kernel_cache_reset_lru(KERNEL_CACHE *kernel_cache)$/;"	f
kernel_cache_shrink	../svm_light/svm_learn.c	/^void kernel_cache_shrink(KERNEL_CACHE *kernel_cache, long int totdoc, $/;"	f
kernel_cache_size	../svm_light/svm_common.h	/^  long   kernel_cache_size;    \/* size of kernel cache in megabytes *\/$/;"	m	struct:learn_parm
kernel_cache_space_available	../svm_light/svm_learn.c	/^long kernel_cache_space_available(KERNEL_CACHE *kernel_cache)$/;"	f
kernel_cache_statistic	../svm_light/svm_common.c	/^long   kernel_cache_statistic;$/;"	v
kernel_cache_touch	../svm_light/svm_learn.c	/^long kernel_cache_touch(KERNEL_CACHE *kernel_cache, long int docnum)$/;"	f
kernel_id	../svm_light/svm_common.h	/^  long    kernel_id;           \/* Feature vectors with different$/;"	m	struct:svector
kernel_parm	../svm_light/svm_common.h	/^  KERNEL_PARM kernel_parm; \/* kernel *\/$/;"	m	struct:model
kernel_parm	../svm_light/svm_common.h	/^typedef struct kernel_parm {$/;"	s
kernel_parm	../svm_light/svm_learn.h	/^  KERNEL_PARM *kernel_parm;$/;"	m	struct:cache_parm_s
kernel_type	../svm_light/svm_common.h	/^  long    kernel_type;   \/* 0=linear, 1=poly, 2=rbf, 3=sigmoid,$/;"	m	struct:kernel_parm
kernelid	../svm_light/svm_common.h	/^  long    kernelid;            \/* Position in gram matrix where kernel$/;"	m	struct:doc
label	../include/svm_struct_api_types.h	/^typedef struct label {$/;"	s
ladd_matrix	../svm_light/svm_hideo.c	/^void ladd_matrix(matrix,depth,scalar)$/;"	f
last_a	../svm_light/svm_common.h	/^  double *last_a;      \/* for shrinking with linear kernel *\/$/;"	m	struct:shrink_state
last_lin	../svm_light/svm_common.h	/^  double *last_lin;    \/* for shrinking with linear kernel *\/$/;"	m	struct:shrink_state
lcopy_matrix	../svm_light/svm_hideo.c	/^void lcopy_matrix(matrix,depth,matrix2) $/;"	f
learn_parm	../svm_light/svm_common.h	/^typedef struct learn_parm {$/;"	s
length_of_longest_document_vector	../svm_light/svm_learn.c	/^double length_of_longest_document_vector(DOC **docs, long int totdoc, $/;"	f
lin_weights	../svm_light/svm_common.h	/^  double  *lin_weights;                       \/* weights for linear case using$/;"	m	struct:model
lindep_sensitivity	../svm_light/svm_hideo.c	/^double lindep_sensitivity=DEF_LINDEP_SENSITIVITY;$/;"	v
linvert_matrix	../svm_light/svm_hideo.c	/^void linvert_matrix(matrix,depth,inverse,lindep_sensitivity,lin_dependent)$/;"	f
loo_error	../svm_light/svm_common.h	/^  double  loo_error,loo_recall,loo_precision; \/* leave-one-out estimates *\/$/;"	m	struct:model
loo_precision	../svm_light/svm_common.h	/^  double  loo_error,loo_recall,loo_precision; \/* leave-one-out estimates *\/$/;"	m	struct:model
loo_recall	../svm_light/svm_common.h	/^  double  loo_error,loo_recall,loo_precision; \/* leave-one-out estimates *\/$/;"	m	struct:model
loss_function	../include/svm_struct_api_types.h	/^  int    loss_function;        \/* select between different loss$/;"	m	struct:struct_learn_parm
loss_type	../include/svm_struct_api_types.h	/^  int    loss_type;            \/* selected loss type from -r$/;"	m	struct:struct_learn_parm
lprint_matrix	../svm_light/svm_hideo.c	/^void lprint_matrix(matrix,depth)$/;"	f
lru	../svm_light/svm_common.h	/^  long   *lru;$/;"	m	struct:kernel_cache
lswitch_rows_matrix	../svm_light/svm_hideo.c	/^void lswitch_rows_matrix(matrix,depth,r1,r2) $/;"	f
lswitchrk_matrix	../svm_light/svm_hideo.c	/^void lswitchrk_matrix(matrix,depth,rk1,rk2) $/;"	f
m	../svm_light/svm_common.h	/^  int m; \/* number of colums *\/$/;"	m	struct:matrix
m	../svm_light/svm_learn.h	/^  long m;$/;"	m	struct:cache_parm_s
main	../svm_light/svm_classify.c	/^int main (int argc, char* argv[])$/;"	f
main	../svm_light/svm_learn_main.c	/^int main (int argc, char* argv[])$/;"	f
main	../svm_struct/svm_struct_classify.c	/^int main (int argc, char* argv[])$/;"	f
main	../svm_struct/svm_struct_main.c	/^int main (int argc, char* argv[])$/;"	f
matrix	../svm_light/svm_common.h	/^typedef struct matrix {$/;"	s
max_elems	../svm_light/svm_common.h	/^  long   max_elems;$/;"	m	struct:kernel_cache
maxdiff	../svm_light/svm_common.h	/^  double  maxdiff;                            \/* precision, up to which this $/;"	m	struct:model
maxhistory	../svm_light/svm_common.h	/^  long   maxhistory;$/;"	m	struct:shrink_state
maxiter	../svm_light/svm_common.h	/^  long   maxiter;              \/* number of iterations after which the$/;"	m	struct:learn_parm
maxiter	../svm_light/svm_hideo.c	/^long   maxiter=DEF_MAX_ITERATIONS;$/;"	v
maxl	../svm_light/svm_common.c	/^long maxl(long int a, long int b)$/;"	f
minl	../svm_light/svm_common.c	/^long minl(long int a, long int b)$/;"	f
model	../svm_light/svm_common.h	/^typedef struct model {$/;"	s
model_b	../svm_light/svm_loqo.c	/^double model_b;$/;"	v
model_length_n	../svm_light/svm_common.c	/^double model_length_n(MODEL *model) $/;"	f
model_length_s	../svm_light/svm_common.c	/^double model_length_s(MODEL *model) $/;"	f
modelfile	../svm_light/svm_classify.c	/^char modelfile[200];$/;"	v
modelfile	../svm_light/svm_learn_main.c	/^char modelfile[200];         \/* file for resulting classifier *\/$/;"	v
modelfile	../svm_struct/svm_struct_classify.c	/^char modelfile[200];$/;"	v
modelfile	../svm_struct/svm_struct_main.c	/^char modelfile[200];           \/* file for resulting classifier *\/$/;"	v
mult_svector_list	../svm_light/svm_common.c	/^void mult_svector_list(SVECTOR *a, double factor) $/;"	f
mult_vector_ns	../svm_light/svm_common.c	/^void mult_vector_ns(double *vec_n, SVECTOR *vec_s, double faktor)$/;"	f
multadd_ss	../svm_light/svm_common.c	/^SVECTOR* multadd_ss(SVECTOR *a, SVECTOR *b, double fa, double fb)$/;"	f
multadd_ss_r	../svm_light/svm_common.c	/^SVECTOR* multadd_ss_r(SVECTOR *a,SVECTOR *b,double fa, double fb,$/;"	f
my_malloc	../svm_light/svm_common.c	/^void *my_malloc(size_t size)$/;"	f
n	../svm_light/svm_common.h	/^  int n; \/* number of rows *\/$/;"	m	struct:matrix
newconstretrain	../include/svm_struct_api_types.h	/^  double newconstretrain;      \/* number of new constraints to$/;"	m	struct:struct_learn_parm
next	../svm_light/svm_common.h	/^  struct svector *next;        \/* Let's you set up a list of SVECTOR's$/;"	m	struct:svector	typeref:struct:svector::svector
nol_ll	../svm_light/svm_common.c	/^void nol_ll(char *file, long int *nol, long int *wol, long int *ll) $/;"	f
nonoptimal	../svm_light/svm_hideo.c	/^long   *nonoptimal;$/;"	v
occu	../svm_light/svm_common.h	/^  long   *occu;$/;"	m	struct:kernel_cache
offset	../svm_light/svm_learn.h	/^  long offset,stepsize;$/;"	m	struct:cache_parm_s
opt_ce	../svm_light/svm_common.h	/^  double *opt_ce,*opt_ce0; \/* linear equality constraints $/;"	m	struct:quadratic_program
opt_ce0	../svm_light/svm_common.h	/^  double *opt_ce,*opt_ce0; \/* linear equality constraints $/;"	m	struct:quadratic_program
opt_g	../svm_light/svm_common.h	/^  double *opt_g;           \/* hessian of objective *\/$/;"	m	struct:quadratic_program
opt_g0	../svm_light/svm_common.h	/^  double *opt_g0;          \/* linear part of objective *\/$/;"	m	struct:quadratic_program
opt_low	../svm_light/svm_common.h	/^  double *opt_low,*opt_up; \/* box constraints *\/$/;"	m	struct:quadratic_program
opt_m	../svm_light/svm_common.h	/^  long   opt_m;            \/* number of linear equality constraints *\/$/;"	m	struct:quadratic_program
opt_n	../svm_light/svm_common.h	/^  long   opt_n;            \/* number of variables *\/$/;"	m	struct:quadratic_program
opt_precision	../svm_light/svm_common.h	/^  double opt_precision;        \/* precision of solver, set to e.g. 1e-21 $/;"	m	struct:learn_parm
opt_precision	../svm_light/svm_hideo.c	/^double opt_precision=DEF_PRECISION;$/;"	v
opt_precision	../svm_light/svm_loqo.c	/^double opt_precision=DEF_PRECISION_LINEAR;$/;"	v
opt_up	../svm_light/svm_common.h	/^  double *opt_low,*opt_up; \/* box constraints *\/$/;"	m	struct:quadratic_program
opt_xinit	../svm_light/svm_common.h	/^  double *opt_xinit;       \/* initial value for variables *\/$/;"	m	struct:quadratic_program
optimize_hildreth_despo	../svm_light/svm_hideo.c	/^int optimize_hildreth_despo(n,m,precision,epsilon_crit,epsilon_a,maxiter,goal,$/;"	f
optimize_qp	../svm_light/svm_hideo.c	/^double *optimize_qp(qp,epsilon_crit,nx,threshold,learn_parm)$/;"	f
optimize_qp	../svm_light/svm_loqo.c	/^double *optimize_qp(qp,epsilon_crit,nx,threshold,learn_parm)$/;"	f
optimize_svm	../svm_light/svm_learn.c	/^void optimize_svm(DOC **docs, long int *label, long int *unlabeled, $/;"	f
optimize_to_convergence	../svm_light/svm_learn.c	/^long optimize_to_convergence(DOC **docs, long int *label, long int totdoc, $/;"	f
optimize_to_convergence_sharedslack	../svm_light/svm_learn.c	/^long optimize_to_convergence_sharedslack(DOC **docs, long int *label, $/;"	f
parse_document	../svm_light/svm_common.c	/^int parse_document(char *line, WORD *words, double *label,$/;"	f
pattern	../include/svm_struct_api_types.h	/^typedef struct pattern {$/;"	s
poly_degree	../svm_light/svm_common.h	/^  long    poly_degree;$/;"	m	struct:kernel_parm
precision_violations	../svm_light/svm_hideo.c	/^long   precision_violations=0;$/;"	v
precision_violations	../svm_light/svm_loqo.c	/^long   init_iter=500,precision_violations=0;$/;"	v
predfile	../svm_light/svm_common.h	/^  char predfile[200];          \/* file for predicitions on unlabeled examples$/;"	m	struct:learn_parm
predictionsfile	../svm_light/svm_classify.c	/^char predictionsfile[200];$/;"	v
predictionsfile	../svm_struct/svm_struct_classify.c	/^char predictionsfile[200];$/;"	v
primal	../svm_light/svm_hideo.c	/^double *primal=0,*dual=0;$/;"	v
primal	../svm_light/svm_loqo.c	/^double *primal=0,*dual=0;$/;"	v
printDoubleArray	../svm_struct/svm_struct_common.c	/^void printDoubleArray(double* x, int n)$/;"	f
printIntArray	../svm_struct/svm_struct_common.c	/^void printIntArray(int* x, int n)$/;"	f
printW	../svm_struct/svm_struct_common.c	/^void printW(double *w, long sizePhi, long n,double C)$/;"	f
printWordArray	../svm_struct/svm_struct_common.c	/^void printWordArray(WORD* x)$/;"	f
print_help	../svm_light/svm_classify.c	/^void print_help(void)$/;"	f
print_help	../svm_light/svm_learn_main.c	/^void print_help()$/;"	f
print_help	../svm_struct/svm_struct_classify.c	/^void print_help(void)$/;"	f
print_help	../svm_struct/svm_struct_main.c	/^void print_help()$/;"	f
print_matrix	../svm_light/svm_common.c	/^void print_matrix(MATRIX *matrix)$/;"	f
print_percent_progress	../svm_light/svm_common.c	/^void print_percent_progress(long *progress, long maximum, $/;"	f
prod_ltmatrix_nvector	../svm_light/svm_common.c	/^double *prod_ltmatrix_nvector(MATRIX *A, double *v)$/;"	f
prod_matrix_matrix	../svm_light/svm_common.c	/^MATRIX *prod_matrix_matrix(MATRIX *A, MATRIX *B)$/;"	f
prod_matrix_nvector	../svm_light/svm_common.c	/^double *prod_matrix_nvector(MATRIX *A, double *v)$/;"	f
prod_nvector_ltmatrix	../svm_light/svm_common.c	/^double *prod_nvector_ltmatrix(double *v, MATRIX *A)$/;"	f
prod_nvector_matrix	../svm_light/svm_common.c	/^double *prod_nvector_matrix(double *v, MATRIX *A)$/;"	f
quadratic_program	../svm_light/svm_common.h	/^typedef struct quadratic_program {$/;"	s
queryid	../svm_light/svm_common.h	/^  long    queryid;             \/* for learning rankings, constraints are $/;"	m	struct:doc
random_order	../svm_light/svm_common.c	/^long *random_order(long n)$/;"	f
randpair	../svm_light/svm_common.h	/^typedef struct randpair {$/;"	s
rbf_gamma	../svm_light/svm_common.h	/^  double  rbf_gamma;$/;"	m	struct:kernel_parm
reactivate_inactive_examples	../svm_light/svm_learn.c	/^void reactivate_inactive_examples(long int *label, $/;"	f
read_alphas	../svm_light/svm_common.c	/^double *read_alphas(char *alphafile,long totdoc)$/;"	f
read_documents	../svm_light/svm_common.c	/^void read_documents(char *docfile, DOC ***docs, double **label, $/;"	f
read_input_parameters	../svm_light/svm_classify.c	/^void read_input_parameters(int argc, char **argv, char *docfile, $/;"	f
read_input_parameters	../svm_light/svm_learn_main.c	/^void read_input_parameters(int argc,char *argv[],char *docfile,char *modelfile,$/;"	f
read_input_parameters	../svm_struct/svm_struct_classify.c	/^void read_input_parameters(int argc,char *argv[],char *testfile,$/;"	f
read_input_parameters	../svm_struct/svm_struct_main.c	/^void read_input_parameters(int argc,char *argv[],char *trainfile,$/;"	f
read_model	../svm_light/svm_common.c	/^MODEL *read_model(char *modelfile)$/;"	f
read_word	../svm_light/svm_common.c	/^int read_word(char *in, char *out) {$/;"	f
realloc_matrix	../svm_light/svm_common.c	/^MATRIX *realloc_matrix(MATRIX *matrix, int n, int m)$/;"	f
remove_inactive_constraints	../svm_struct/svm_struct_learn.c	/^void remove_inactive_constraints(CONSTSET *cset, double *alpha, $/;"	f
remove_inconsistent	../svm_light/svm_common.h	/^  long   remove_inconsistent;  \/* exclude examples with alpha at C and $/;"	m	struct:learn_parm
restartfile	../svm_light/svm_learn_main.c	/^char restartfile[200];       \/* file with initial alphas *\/$/;"	v
rho	../svm_light/svm_common.h	/^  double rho;                  \/* parameter in xi\/alpha-estimates and for$/;"	m	struct:learn_parm
roundnumber	../svm_light/svm_hideo.c	/^long  roundnumber=0;$/;"	v
select_next_qp_slackset	../svm_light/svm_learn.c	/^long select_next_qp_slackset(DOC **docs, long int *label, $/;"	f
select_next_qp_subproblem_grad	../svm_light/svm_learn.c	/^long select_next_qp_subproblem_grad(long int *label, $/;"	f
select_next_qp_subproblem_rand	../svm_light/svm_learn.c	/^long select_next_qp_subproblem_rand(long int *label, $/;"	f
select_top_n	../svm_light/svm_learn.c	/^void select_top_n(double *selcrit, long int range, long int *select, $/;"	f
set_learning_defaults	../svm_light/svm_common.c	/^void set_learning_defaults(LEARN_PARM *learn_parm, KERNEL_PARM *kernel_parm)$/;"	f
setfactor_svector_list	../svm_light/svm_common.c	/^void setfactor_svector_list(SVECTOR *a, double factor) $/;"	f
sharedslack	../svm_light/svm_common.h	/^  long   sharedslack;          \/* if nonzero, it will use the shared$/;"	m	struct:learn_parm
shift_s	../svm_light/svm_common.c	/^SVECTOR* shift_s(SVECTOR *a, long shift) $/;"	f
shrink_problem	../svm_light/svm_learn.c	/^long shrink_problem(DOC **docs,$/;"	f
shrink_state	../svm_light/svm_common.h	/^typedef struct shrink_state {$/;"	s
shrink_state_cleanup	../svm_light/svm_learn.c	/^void shrink_state_cleanup(SHRINK_STATE *shrink_state)$/;"	f
single_kernel	../svm_light/svm_common.c	/^double single_kernel(KERNEL_PARM *kernel_parm, SVECTOR *a, SVECTOR *b) $/;"	f
sizePsi	../include/svm_struct_api_types.h	/^  long   sizePsi;     \/* maximum number of weights in w *\/$/;"	m	struct:structmodel
skip_final_opt_check	../svm_light/svm_common.h	/^  long   skip_final_opt_check; \/* do not check KT-Conditions at the end of$/;"	m	struct:learn_parm
slack_norm	../include/svm_struct_api_types.h	/^  int    slack_norm;           \/* norm to use in objective function$/;"	m	struct:struct_learn_parm
slackid	../svm_light/svm_common.h	/^  long    slackid;             \/* Index of the slack variable$/;"	m	struct:doc
smallroundcount	../svm_light/svm_hideo.c	/^long  smallroundcount=0;$/;"	v
smult_s	../svm_light/svm_common.c	/^SVECTOR* smult_s(SVECTOR *a, double factor) $/;"	f
solve_dual	../svm_light/svm_hideo.c	/^int solve_dual(n,m,precision,epsilon_crit,maxiter,g,g0,ce,ce0,low,up,primal,$/;"	f
sort	../svm_light/svm_common.h	/^  long   val,sort;$/;"	m	struct:randpair
space_or_null	../svm_light/svm_common.c	/^int space_or_null(int c) {$/;"	f
sprod_ns	../svm_light/svm_common.c	/^double sprod_ns(double *vec_n, SVECTOR *vec_s)$/;"	f
sprod_ss	../svm_light/svm_common.c	/^double sprod_ss(SVECTOR *a, SVECTOR *b) $/;"	f
stepsize	../svm_light/svm_learn.h	/^  long offset,stepsize;$/;"	m	struct:cache_parm_s
struct_learn_parm	../include/svm_struct_api_types.h	/^typedef struct struct_learn_parm {$/;"	s
struct_test_stats	../include/svm_struct_api_types.h	/^typedef struct struct_test_stats {$/;"	s
struct_verbosity	../svm_struct/svm_struct_common.c	/^long struct_verbosity;                   \/* verbosity level (0-4) *\/$/;"	v
structmodel	../include/svm_struct_api_types.h	/^typedef struct structmodel {$/;"	s
sub_ss	../svm_light/svm_common.c	/^SVECTOR* sub_ss(SVECTOR *a, SVECTOR *b) $/;"	f
sub_ss_r	../svm_light/svm_common.c	/^SVECTOR* sub_ss_r(SVECTOR *a, SVECTOR *b, double min_non_zero) $/;"	f
supvec	../svm_light/svm_common.h	/^  DOC     **supvec;$/;"	m	struct:model
sv_num	../svm_light/svm_common.h	/^  long    sv_num;	$/;"	m	struct:model
svector	../svm_light/svm_common.h	/^typedef struct svector {$/;"	s
svm_c	../svm_light/svm_common.h	/^  double svm_c;                \/* upper bound C on alphas *\/$/;"	m	struct:learn_parm
svm_c_factor	../svm_light/svm_common.h	/^  double svm_c_factor;         \/* increase C by this factor every step *\/$/;"	m	struct:learn_parm
svm_c_steps	../svm_light/svm_common.h	/^  long   svm_c_steps;          \/* do so many steps for finding optimal C *\/$/;"	m	struct:learn_parm
svm_cost	../svm_light/svm_common.h	/^  double *svm_cost;            \/* individual upper bounds for each var *\/$/;"	m	struct:learn_parm
svm_costratio	../svm_light/svm_common.h	/^  double svm_costratio;        \/* factor to multiply C for positive examples *\/$/;"	m	struct:learn_parm
svm_costratio_unlab	../svm_light/svm_common.h	/^  double svm_costratio_unlab;$/;"	m	struct:learn_parm
svm_iter_to_shrink	../svm_light/svm_common.h	/^  long   svm_iter_to_shrink;   \/* iterations h after which an example can$/;"	m	struct:learn_parm
svm_learn_classification	../svm_light/svm_learn.c	/^void svm_learn_classification(DOC **docs, double *class, long int$/;"	f
svm_learn_optimization	../svm_light/svm_learn.c	/^void svm_learn_optimization(DOC **docs, double *rhs, long int$/;"	f
svm_learn_ranking	../svm_light/svm_learn.c	/^void svm_learn_ranking(DOC **docs, double *rankvalue, long int totdoc, $/;"	f
svm_learn_regression	../svm_light/svm_learn.c	/^void svm_learn_regression(DOC **docs, double *value, long int totdoc, $/;"	f
svm_learn_struct	../svm_struct/svm_struct_learn.c	/^void svm_learn_struct(SAMPLE sample, STRUCT_LEARN_PARM *sparm,$/;"	f
svm_learn_struct_joint	../svm_struct/svm_struct_learn.c	/^void svm_learn_struct_joint(SAMPLE sample, STRUCT_LEARN_PARM *sparm,$/;"	f
svm_maxqpsize	../svm_light/svm_common.h	/^  long   svm_maxqpsize;        \/* size q of working set *\/$/;"	m	struct:learn_parm
svm_model	../include/svm_struct_api_types.h	/^  MODEL  *svm_model;  \/* the learned SVM model *\/$/;"	m	struct:structmodel
svm_newvarsinqp	../svm_light/svm_common.h	/^  long   svm_newvarsinqp;      \/* new variables to enter the working set $/;"	m	struct:learn_parm
svm_struct_api	../include/svm_struct_api.h	24;"	d
svm_struct_api_types	../include/svm_struct_api_types.h	21;"	d
svm_unlabbound	../svm_light/svm_common.h	/^  double svm_unlabbound;$/;"	m	struct:learn_parm
testfile	../svm_struct/svm_struct_classify.c	/^char testfile[200];$/;"	v
time	../svm_light/svm_common.h	/^  long   time;$/;"	m	struct:kernel_cache
time_check	../svm_light/svm_common.h	/^  double   time_check;$/;"	m	struct:timing_profile
time_kernel	../svm_light/svm_common.h	/^  double   time_kernel;$/;"	m	struct:timing_profile
time_model	../svm_light/svm_common.h	/^  double   time_model;$/;"	m	struct:timing_profile
time_opti	../svm_light/svm_common.h	/^  double   time_opti;$/;"	m	struct:timing_profile
time_select	../svm_light/svm_common.h	/^  double   time_select;$/;"	m	struct:timing_profile
time_shrink	../svm_light/svm_common.h	/^  double   time_shrink;$/;"	m	struct:timing_profile
time_update	../svm_light/svm_common.h	/^  double   time_update;$/;"	m	struct:timing_profile
timing_profile	../svm_light/svm_common.h	/^typedef struct timing_profile {$/;"	s
totdoc	../svm_light/svm_common.h	/^  long    totdoc;       \/* number of training documents *\/$/;"	m	struct:model
totdoc2active	../svm_light/svm_common.h	/^  long   *totdoc2active;$/;"	m	struct:kernel_cache
totwords	../svm_light/svm_common.h	/^  long    totwords;     \/* number of features *\/$/;"	m	struct:model
totwords	../svm_light/svm_common.h	/^  long   totwords;             \/* number of features *\/$/;"	m	struct:learn_parm
trainfile	../svm_struct/svm_struct_main.c	/^char trainfile[200];           \/* file with training examples *\/$/;"	v
transduction_posratio	../svm_light/svm_common.h	/^  double transduction_posratio;\/* fraction of unlabeled examples to be *\/$/;"	m	struct:learn_parm
transpose_matrix	../svm_light/svm_common.c	/^MATRIX *transpose_matrix(MATRIX *matrix)$/;"	f
twonorm_sq	../svm_light/svm_common.h	/^  double  twonorm_sq;          \/* The squared euclidian length of the$/;"	m	struct:svector
type	../svm_light/svm_common.h	/^  long   type;                 \/* selects between regression and$/;"	m	struct:learn_parm
update_constraint_cache_for_model	../svm_struct/svm_struct_learn.c	/^void update_constraint_cache_for_model(CCACHE *ccache, MODEL *svmModel)$/;"	f
update_kernel_matrix	../svm_struct/svm_struct_learn.c	/^MATRIX *update_kernel_matrix(MATRIX *matrix, int newpos, CONSTSET *cset, $/;"	f
update_linear_component	../svm_light/svm_learn.c	/^void update_linear_component(DOC **docs, long int *label, $/;"	f
userdefined	../svm_light/svm_common.h	/^  char    *userdefined;        \/* You can put additional information$/;"	m	struct:svector
val	../svm_light/svm_common.h	/^  long   val,sort;$/;"	m	struct:randpair
verbosity	../svm_light/svm_common.c	/^long   verbosity;              \/* verbosity level (0-4) *\/$/;"	v
verbosity	../svm_light/svm_hideo.c	/^long verbosity;$/;"	v
verbosity	../svm_light/svm_loqo.c	/^long verbosity;$/;"	v
w	../include/svm_struct_api_types.h	/^  double *w;          \/* pointer to the learned weights *\/$/;"	m	struct:structmodel
wait_any_key	../svm_light/svm_learn_main.c	/^void wait_any_key()$/;"	f
wait_any_key	../svm_struct/svm_struct_main.c	/^void wait_any_key()$/;"	f
walpha	../include/svm_struct_api_types.h	/^  double walpha;$/;"	m	struct:structmodel
weight	../svm_light/svm_common.h	/^  FVAL    weight;              \/* word weight *\/$/;"	m	struct:word
wnum	../svm_light/svm_common.h	/^  FNUM    wnum;	               \/* word number *\/$/;"	m	struct:word
word	../svm_light/svm_common.h	/^typedef struct word {$/;"	s
words	../svm_light/svm_common.h	/^  WORD    *words;              \/* The features\/values in the vector by$/;"	m	struct:svector
write_alphas	../svm_light/svm_learn.c	/^void write_alphas(char *alphafile, double *a, $/;"	f
write_model	../svm_light/svm_common.c	/^void write_model(char *modelfile, MODEL *model)$/;"	f
write_prediction	../svm_light/svm_learn.c	/^void write_prediction(char *predfile, MODEL *model, double *lin, $/;"	f
xa_depth	../svm_light/svm_common.h	/^  long   xa_depth;             \/* parameter in xi\/alpha-estimates upper$/;"	m	struct:learn_parm
xa_error	../svm_light/svm_common.h	/^  double  xa_error,xa_recall,xa_precision;    \/* xi\/alpha estimates *\/$/;"	m	struct:model
xa_precision	../svm_light/svm_common.h	/^  double  xa_error,xa_recall,xa_precision;    \/* xi\/alpha estimates *\/$/;"	m	struct:model
xa_recall	../svm_light/svm_common.h	/^  double  xa_error,xa_recall,xa_precision;    \/* xi\/alpha estimates *\/$/;"	m	struct:model
